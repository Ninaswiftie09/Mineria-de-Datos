---
title: "Laboratorio 1"
output:
  html_document:
    df_print: paged
  word_document: default
  pdf_document:
    latex_engine: xelatex
header-includes:
  - \usepackage{float}
  - \usepackage[margin=1in]{geometry}
---

## Integrantes
- Nina Nájera - 231088  
- Mishell Ciprian - 231169  
- Diego Ramirez - 23601  

```{r setup, include=FALSE}
knitr::opts_chunk$set(
  echo = FALSE,
  message = FALSE,
  warning = FALSE
)

library(tidyverse)
library(knitr)
library(lubridate)
library(scales)
library(stringr)
library(purrr)

if (!requireNamespace("nortest", quietly = TRUE)) install.packages("nortest")
library(nortest)

movies <- read.csv("movies_2026.csv", stringsAsFactors = FALSE, fileEncoding = "UTF-8")

# Arreglar posibles caracteres raros (evita errores de UTF-8 al imprimir tablas)
movies <- movies %>%
  mutate(across(where(is.character), ~ iconv(.x, from = "", to = "UTF-8", sub = "")))

movies <- movies %>%
  mutate(
    genres = na_if(str_trim(genres), ""),
    productionCountry = na_if(str_trim(productionCountry), ""),
    productionCompanyCountry = na_if(str_trim(productionCompanyCountry), ""),
    homePage = na_if(str_trim(homePage), ""),
    actorsPopularity = na_if(str_trim(actorsPopularity), ""),
    releaseDate = na_if(str_trim(releaseDate), "")
  ) %>%
  mutate(
    releaseDate = suppressWarnings(as.Date(releaseDate)),
    releaseYear = if_else(!is.na(releaseDate), year(releaseDate), as.integer(releaseYear)),
    releaseMonth = if_else(!is.na(releaseDate), month(releaseDate, label = TRUE, abbr = TRUE), NA)
  ) %>%
  mutate(
    main_genre = map_chr(str_split(genres %||% "", "\\|"), ~ ifelse(length(.x) >= 1 && .x[1] != "", .x[1], NA_character_)),
    productionCountry_main = map_chr(str_split(productionCountry %||% "", "\\|"), ~ ifelse(length(.x) >= 1 && .x[1] != "", .x[1], NA_character_))
  )
```
### Recomendación.
  Recomendamos que corran el archivo en html ya que en PDF por algún motivo que aún desconocemos porque algunas tablas o gráficos se están corriendo a la derecha, pero en html no pasa eso. 

### Link del repositorio: 
  https://github.com/Ninaswiftie09/Mineria-de-Datos 

## Ejercicio 1

> **Enunciado:** Haga una exploración rápida de sus datos (resumen del conjunto de datos).

```{r ejercicio1_resumen}
dim(movies)
names(movies)
dplyr::glimpse(movies)
summary(movies)

na_by_col <- sort(colSums(is.na(movies)), decreasing = TRUE)
na_by_col[1:15]
```

**Comentario:**  
Con esto vemos rápido: el tamaño del dataset, las columnas que existen, el tipo de datos, valores típicos y cuáles variables tienen más datos faltantes (NA).

---

## Ejercicio 2

### Tipos de variables (según su naturaleza)

- **id**: Identificador (no se analiza como variable)
- **popularity**: Cuantitativa continua  
- **budget**: Cuantitativa continua  
- **revenue**: Cuantitativa continua  
- **originalTitle**: Cualitativa nominal  
- **originalLanguage**: Cualitativa nominal  
- **title**: Cualitativa nominal  
- **homePage**: Cualitativa nominal (sí/no, según exista)  
- **video**: Cualitativa nominal dicotómica  
- **director**: Cualitativa nominal  
- **runtime**: Cuantitativa continua  
- **genres**: Cualitativa nominal (texto, a veces combinada)  
- **genresAmount**: Cuantitativa discreta  
- **productionCompany**: Cualitativa nominal  
- **productionCoAmount**: Cuantitativa discreta  
- **productionCompanyCountry**: Cualitativa nominal  
- **productionCountry**: Cualitativa nominal  
- **productionCountriesAmount**: Cuantitativa discreta  
- **releaseDate**: Variable temporal (fecha)  
- **voteCount**: Cuantitativa discreta  
- **voteAvg**: Cuantitativa continua  
- **actors**: Cualitativa nominal  
- **actorsPopularity**: Cuantitativa continua (lista por actor)  
- **actorsCharacter**: Cualitativa nominal  
- **actorsAmount**: Cuantitativa discreta  
- **castWomenAmount**: Cuantitativa discreta  
- **castMenAmount**: Cuantitativa discreta  
- **releaseYear**: Cuantitativa discreta (año)

---

## Ejercicio 3

### 3.1 Variables cuantitativas

```{r}
quant_vars <- movies %>%
  select(
    popularity, budget, revenue, runtime, voteAvg, voteCount,
    actorsAmount, castWomenAmount, castMenAmount
  )
```

#### Histogramas (vista general)

```{r fig.width=8.5, fig.height=6, fig.align='center', out.width="0.98\\linewidth"}
quant_vars %>%
  pivot_longer(cols = everything()) %>%
  ggplot(aes(x = value)) +
  geom_histogram(bins = 30) +
  facet_wrap(~name, scales = "free", ncol = 3) +
  theme_minimal(base_size = 10) +
  theme(
    strip.text = element_text(size = 9),
    plot.margin = margin(6, 6, 6, 6)
  )
```

**Explicación:**  
Los histogramas ayudan a ver cómo se distribuye cada variable (si está muy cargada a un lado, si hay valores extremos, etc.).

#### Histogramas en escala log (solo para variables muy grandes)

```{r}
quant_log <- quant_vars %>%
  mutate(
    budget = ifelse(budget <= 0, NA, budget),
    revenue = ifelse(revenue <= 0, NA, revenue),
    voteCount = ifelse(voteCount <= 0, NA, voteCount)
  ) %>%
  select(budget, revenue, voteCount) %>%
  pivot_longer(everything()) %>%
  filter(!is.na(value))

ggplot(quant_log, aes(x = log10(value))) +
  geom_histogram(bins = 30) +
  facet_wrap(~name, scales = "free", ncol = 3) +
  theme_minimal() +
  labs(x = "log10(valor)")
```

**Explicación:**  
Como presupuesto/ingresos/votos tienen valores enormes, la escala log nos deja ver mejor el patrón sin que todo se aplaste por unos pocos valores muy altos.

#### Prueba de normalidad (Lilliefors)

```{r}
lillie_results <- sapply(quant_vars, function(x) {
  x <- na.omit(x)
  nortest::lillie.test(x)$p.value
})

lillie_tbl <- tibble(
  variable = names(lillie_results),
  p_value = as.numeric(lillie_results),
  normalidad = if_else(p_value < 0.05, "No normal", "No se rechaza normalidad")
) %>% arrange(p_value)

kable(lillie_tbl, digits = 6, caption = "Prueba de normalidad de Lilliefors por variable")
```

**Conclusión:**  
Si el **p-value < 0.05**, se rechaza la normalidad. En este dataset, la mayoría de variables cuantitativas dan p-values muy pequeños, así que **no siguen una distribución normal**.

---

### 3.2 Variables cualitativas

> Nota: Para no hacer el reporte eterno, se muestra **Top 10 + Otros** cuando hay muchas categorías.

```{r}
top_n <- 10
```

#### Tablas de frecuencia

**Idioma original (originalLanguage)**

```{r}
freq_language <- movies %>%
  count(originalLanguage, sort = TRUE) %>%
  mutate(percentage = n / sum(n) * 100)

kable(
  head(freq_language, top_n),
  col.names = c("Idioma original", "Frecuencia", "Porcentaje (%)"),
  digits = 2,
  caption = paste0("Top ", top_n, " idiomas originales")
)
```

**Explicación:**  
Aquí se observa qué idiomas aparecen más en el dataset. Generalmente pocos idiomas dominan y los demás son menos frecuentes.

**Género principal (main_genre) – Top 10 + Otros**

```{r}
freq_main_genre <- movies %>%
  filter(!is.na(main_genre)) %>%
  count(main_genre, sort = TRUE) %>%
  mutate(grupo = if_else(row_number() <= top_n, main_genre, "Otros")) %>%
  group_by(grupo) %>%
  summarise(n = sum(n), .groups = "drop") %>%
  mutate(percentage = n / sum(n) * 100) %>%
  arrange(desc(n))

kable(
  freq_main_genre,
  col.names = c("Género principal", "Frecuencia", "Porcentaje (%)"),
  digits = 2,
  caption = paste0("Frecuencia de géneros principales (Top ", top_n, " + Otros)")
)
```

**Explicación:**  
Se usa el **género principal** (el primero) para resumir mejor. Normalmente pocos géneros concentran gran parte de las películas.

**Videos promocionales (video)**

```{r}
freq_video <- movies %>%
  mutate(video_cat = case_when(
    is.na(video) ~ "Desconocido",
    video %in% c(TRUE, "TRUE", "True", 1, "1") ~ "Sí",
    video %in% c(FALSE, "FALSE", "False", 0, "0") ~ "No",
    TRUE ~ as.character(video)
  )) %>%
  count(video_cat, sort = TRUE) %>%
  mutate(percentage = n / sum(n) * 100)

kable(
  freq_video,
  col.names = c("Video promocional", "Frecuencia", "Porcentaje (%)"),
  digits = 2,
  caption = "Tabla de frecuencias de videos promocionales"
)
```

**Explicación:**  
Se separa “Desconocido” cuando falta el dato, para no mezclarlo con un “No”.

**País de producción (productionCountry_main) – Top 10 + Otros**

```{r}
freq_prod_country <- movies %>%
  filter(!is.na(productionCountry_main)) %>%
  count(productionCountry_main, sort = TRUE) %>%
  mutate(grupo = if_else(row_number() <= top_n, productionCountry_main, "Otros")) %>%
  group_by(grupo) %>%
  summarise(n = sum(n), .groups = "drop") %>%
  mutate(percentage = n / sum(n) * 100) %>%
  arrange(desc(n))

kable(
  freq_prod_country,
  col.names = c("País de producción", "Frecuencia", "Porcentaje (%)"),
  digits = 2,
  caption = paste0("Frecuencia de países de producción (Top ", top_n, " + Otros)")
)
```

**Conclusión:**  
En general, las cualitativas no se reparten parejo: hay categorías que dominan y luego una “cola” larga de categorías raras. Por eso Top 10 + Otros es una forma práctica de resumir.

---


## Ejercicio 5 (Puntos extra)

> 6 preguntas nuevas propuestas para explorar el dataset (y ganar puntos extra).

### 5.1 ¿Qué idiomas tienen mayor ingreso promedio?

```{r}
rev_by_lang <- movies %>%
  filter(revenue > 0, !is.na(originalLanguage)) %>%
  group_by(originalLanguage) %>%
  summarise(avg_revenue = mean(revenue, na.rm = TRUE), n = n(), .groups = "drop") %>%
  filter(n >= 20) %>%
  arrange(desc(avg_revenue))

kable(head(rev_by_lang, 10), caption = "Top 10 idiomas por ingreso promedio (n>=20)") 
```

**Explicación:**  
Se filtra por n>=20 para que no gane un idioma con muy pocas películas.

### 5.2 ¿Más géneros (genresAmount) se asocia con más ingresos?

```{r}
ggplot(movies %>% filter(revenue > 0, genresAmount > 0), aes(x = genresAmount, y = revenue)) +
  geom_point(alpha = 0.35) +
  scale_y_continuous(labels = dollar) +
  theme_minimal() +
  labs(title = "Cantidad de géneros vs ingresos", x = "Cantidad de géneros", y = "Ingresos")

cor(movies$genresAmount, movies$revenue, use = "complete.obs")
```

**Explicación:**  
Esto sirve para ver si películas “más mezcladas” en géneros tienden a generar más taquilla.

### 5.3 ¿Qué tan común es tener homepage por año?

```{r}
homepage_by_year <- movies %>%
  filter(!is.na(releaseYear)) %>%
  mutate(has_homepage = !is.na(homePage)) %>%
  group_by(releaseYear) %>%
  summarise(pct_homepage = mean(has_homepage, na.rm = TRUE) * 100, .groups = "drop")

ggplot(homepage_by_year, aes(x = releaseYear, y = pct_homepage)) +
  geom_line() + geom_point() +
  theme_minimal() +
  labs(title = "Porcentaje de películas con homepage por año", x = "Año", y = "% con homepage")
```

**Explicación:**  
Muestra si con el tiempo se vuelve más común que una película tenga página oficial registrada.

### 5.4 ¿Cómo cambia la popularidad promedio por año?

```{r}
pop_by_year <- movies %>%
  filter(!is.na(releaseYear), !is.na(popularity)) %>%
  group_by(releaseYear) %>%
  summarise(avg_popularity = mean(popularity, na.rm = TRUE), .groups = "drop")

ggplot(pop_by_year, aes(x = releaseYear, y = avg_popularity)) +
  geom_line() + geom_point() +
  theme_minimal() +
  labs(title = "Popularidad promedio por año", x = "Año", y = "Popularidad promedio")
```

**Explicación:**  
Sirve para ver si el dataset refleja años con películas más “populares” en promedio.

### 5.5 ¿Runtime se relaciona con voteAvg?

```{r}
ggplot(movies %>% filter(!is.na(runtime), !is.na(voteAvg)),
       aes(x = runtime, y = voteAvg)) +
  geom_point(alpha = 0.35) +
  theme_minimal() +
  labs(title = "Duración vs calificación promedio", x = "Duración (min)", y = "voteAvg")

cor(movies$runtime, movies$voteAvg, use = "complete.obs")
```

**Explicación:**  
Ayuda a ver si películas más largas tienden a ser mejor o peor calificadas.

### 5.6 ¿Qué países tienen mejor calificación promedio?

```{r}
rating_by_country <- movies %>%
  filter(!is.na(productionCountry_main), voteCount > 100) %>%
  group_by(productionCountry_main) %>%
  summarise(avg_vote = mean(voteAvg, na.rm = TRUE), n = n(), .groups = "drop") %>%
  filter(n >= 20) %>%
  arrange(desc(avg_vote))

kable(head(rating_by_country, 10), caption = "Top 10 países por calificación promedio (n>=20, voteCount>100)")
```

**Explicación:**  
Se filtra por cantidad mínima de películas y votos para que sea más justo el ranking.

